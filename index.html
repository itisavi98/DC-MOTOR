<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DC Motor Numerical Solver — Shunt & Series</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    body { font-family: 'Inter',sans-serif; background:#f6f8fb }
    .card { background:#fff; border:1px solid #e6eef8; border-radius:12px; box-shadow:0 6px 18px rgba(20,40,80,0.04); }
    .result-row { display:flex; justify-content:space-between; padding:0.5rem 0; border-bottom:1px dashed #e6eef8 }
    pre { white-space:pre-wrap; word-break:break-word }
    .small { font-size:0.85rem; color:#475569 }
  </style>
</head>
<body class="p-8">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-4xl font-bold text-center mb-6 text-[#0b5cff]">DC Motor Numerical Solver <span class="text-xl">(Shunt & Series)</span></h1>

    <p class="text-center small mb-6">Enter the known values from the numerical and pick which parameter you want to find. The solver will try to compute the missing values using the standard DC motor equations (iterative solving where needed) and show step-by-step reasoning.</p>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Left: Inputs -->
      <div class="card p-6">
        <div class="flex items-center justify-between mb-4">
          <div>
            <h2 class="text-2xl font-semibold">Problem Setup</h2>
            <p class="small">Choose motor type, enter known quantities (leave unknowns blank), and select the quantity to find.</p>
          </div>
          <div>
            <label class="small">Motor Type</label>
            <select id="motor-type" class="ml-2 p-2 rounded border">
              <option value="shunt">DC Shunt Motor</option>
              <option value="series">DC Series Motor</option>
            </select>
          </div>
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
          <!-- Common inputs -->
          <div>
            <label class="small">Supply Voltage, V (V)</label>
            <input id="V" type="number" step="any" class="w-full p-2 rounded border" placeholder="e.g. 230">
          </div>
          <div>
            <label class="small">Line Current I_L (A)</label>
            <input id="IL" type="number" step="any" class="w-full p-2 rounded border" placeholder="e.g. 10">
          </div>

          <div>
            <label class="small">Armature Resistance R_a (Ω)</label>
            <input id="Ra" type="number" step="any" class="w-full p-2 rounded border" placeholder="e.g. 0.5">
          </div>
          <div id="rf-wrapper">
            <label class="small" id="rf-label">Field / Series Resistance R_f or R_se (Ω)</label>
            <input id="Rf" type="number" step="any" class="w-full p-2 rounded border" placeholder="Shunt: R_sh, Series: R_se">
          </div>

          <div>
            <label class="small">Back EMF E_b (V)</label>
            <input id="Eb" type="number" step="any" class="w-full p-2 rounded border" placeholder="Optional">
          </div>
          <div>
            <label class="small">Armature Current I_a (A)</label>
            <input id="Ia" type="number" step="any" class="w-full p-2 rounded border" placeholder="Optional">
          </div>

          <div>
            <label class="small">Shunt Field Current I_f (A)</label>
            <input id="If" type="number" step="any" class="w-full p-2 rounded border" placeholder="Shunt only">
          </div>
          <div>
            <label class="small">Speed N (rpm)</label>
            <input id="N" type="number" step="any" class="w-full p-2 rounded border" placeholder="Optional">
          </div>

          <div>
            <label class="small">Flux per pole φ (Wb)</label>
            <input id="phi" type="number" step="any" class="w-full p-2 rounded border" placeholder="Optional - often unknown">
          </div>
          <div>
            <label class="small">Torque T (N·m)</label>
            <input id="T" type="number" step="any" class="w-full p-2 rounded border" placeholder="Optional">
          </div>

          <div>
            <label class="small">Poles P</label>
            <input id="P" type="number" step="1" class="w-full p-2 rounded border" placeholder="e.g. 4">
          </div>
          <div>
            <label class="small">Conductors Z</label>
            <input id="Z" type="number" step="1" class="w-full p-2 rounded border" placeholder="e.g. 240">
          </div>

          <div>
            <label class="small">Parallel paths A (A)</label>
            <input id="A" type="number" step="1" class="w-full p-2 rounded border" placeholder="e.g. lap: P, wave: 2">
          </div>
          <div>
            <label class="small">Wanted Parameter</label>
            <select id="wanted" class="w-full p-2 rounded border">
              <option value="auto">Auto (solve all unknowns)</option>
              <option value="Eb">Back EMF (E_b)</option>
              <option value="Ia">Armature current (I_a)</option>
              <option value="If">Field current (I_f)</option>
              <option value="IL">Line current (I_L)</option>
              <option value="Ra">Armature resistance (R_a)</option>
              <option value="Rf">Field/Series resistance (R_f / R_se)</option>
              <option value="N">Speed (N)</option>
              <option value="T">Torque (T)</option>
              <option value="phi">Flux (φ)</option>
            </select>
          </div>

        </div>

        <div class="flex gap-3 mt-4">
          <button id="solve" class="px-4 py-2 bg-[#0b5cff] text-white rounded">Solve</button>
          <button id="clear" class="px-4 py-2 border rounded">Clear</button>
          <button id="example" class="ml-auto px-4 py-2 border rounded">Load Example</button>
        </div>

        <div class="mt-4 small text-gray-600">
          <strong>Formulas used:</strong>
          <ul class="list-disc ml-5">
            <li>Eb = (P * φ * Z * N) / (60 * A)</li>
            <li>P<sub>mech</sub> = Eb × I<sub>a</sub></li>
            <li>T = (P*Z/(2πA)) × φ × I<sub>a</sub></li>
            <li>Shunt: I = I<sub>a</sub> + I<sub>f</sub>, I<sub>f</sub>=V/R<sub>sh</sub>, V=Eb + I<sub>a</sub>R<sub>a</sub></li>
            <li>Series: I = I<sub>a</sub>=I<sub>f</sub>, φ ∝ I, V = Eb + I(Ra+Rse)</li>
          </ul>
        </div>

      </div>

      <!-- Right: Results & Steps -->
      <div class="card p-6">
        <h3 class="text-xl font-semibold mb-2">Results</h3>
        <div id="results" class="mb-4">
          <div class="small text-gray-600 mb-2">Calculated values (only values we could deduce):</div>
          <div id="results-list" class="mb-3"></div>
        </div>

        <h3 class="text-xl font-semibold mb-2">Steps / Reasoning</h3>
        <div id="steps" class="small text-gray-700 p-3 bg-[#f8fafc] rounded h-72 overflow-auto"><pre id="steps-pre">No solution yet. Click Solve to compute.</pre></div>

        <div class="mt-4">
          <button id="export" class="px-4 py-2 border rounded">Export as .html</button>
          <span class="small ml-3 text-gray-500">(download a copy of this page)</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Utilities
    const el = id => document.getElementById(id);
    const fmt = (x, dp=4) => (x===null || x===undefined) ? null : (Math.abs(x) < 1e-12 ? 0 : Number(x).toFixed(dp));

    function parseInputs() {
      const fields = ['V','IL','Ra','Rf','Eb','Ia','If','N','phi','T','P','Z','A'];
      const data = {};
      fields.forEach(f => {
        const v = el(f).value;
        data[f] = v === '' ? null : parseFloat(v);
      });
      data.motor = el('motor-type').value; // 'shunt' or 'series'
      data.wanted = el('wanted').value;
      return data;
    }

    function setResults(map) {
      const container = el('results-list');
      container.innerHTML = '';
      const order = ['V','IL','Ia','If','Ra','Rf','Eb','N','phi','T','P','Z','A'];
      order.forEach(k => {
        if (map[k] !== null && map[k] !== undefined) {
          const labelMap = {
            V:'Supply Voltage V (V)', IL:'Line Current I_L (A)', Ia:'Armature current I_a (A)', If:'Field current I_f (A)', Ra:'Armature R_a (Ω)', Rf:'Field/Series R_f / R_se (Ω)', Eb:'Back EMF E_b (V)', N:'Speed N (rpm)', phi:'Flux φ (Wb)', T:'Torque T (N·m)', P:'Poles P', Z:'Conductors Z', A:'Parallel paths A'
          };
          const row = document.createElement('div');
          row.className = 'result-row';
          row.innerHTML = `<div class="font-medium">${labelMap[k]||k}</div><div class="font-mono text-[#0b5cff]">${fmt(map[k])}${k==='P'||k==='Z'||k==='A'?'':''}</div>`;
          container.appendChild(row);
        }
      });
      if (container.innerHTML === '') container.innerHTML = '<div class="small text-gray-500">No deducible values — provide more known values.</div>';
    }

    function pushStep(steps, txt) { steps.push(txt); el('steps-pre').textContent = steps.join('\n'); }

    function solveShunt(input) {
      const steps = [];
      const data = Object.assign({}, input);
      pushStep(steps, 'Solving as DC SHUNT motor...');

      // defaults for A if not given: lap winding -> A = P; wave -> A = 2. We'll use A = P when provided, else 2
      if (!data.A) data.A = data.P || 2;
      pushStep(steps, `Using A = ${data.A}`);

      // compute If from V and Rf (shunt resistance)
      let iter=0, changed=true;
      while (changed && iter<30) {
        changed = false;
        iter++;

        if (data.V!=null && data.Rf!=null && data.If==null) { data.If = data.V / data.Rf; pushStep(steps, `If = V / R_sh = ${fmt(data.V)} / ${fmt(data.Rf)} = ${fmt(data.If)}`); changed=true; }
        if (data.IL!=null && data.If!=null && data.Ia==null) { data.Ia = data.IL - data.If; pushStep(steps, `I_a = I_L - I_f = ${fmt(data.IL)} - ${fmt(data.If)} = ${fmt(data.Ia)}`); changed=true; }
        if (data.Ia!=null && data.If!=null && data.IL==null) { data.IL = data.Ia + data.If; pushStep(steps, `I_L = I_a + I_f = ${fmt(data.Ia)} + ${fmt(data.If)} = ${fmt(data.IL)}`); changed=true; }
        if (data.V!=null && data.Ra!=null && data.Ia!=null && data.Eb==null) { data.Eb = data.V - data.Ia * data.Ra; pushStep(steps, `E_b = V - I_a*R_a = ${fmt(data.V)} - ${fmt(data.Ia)}*${fmt(data.Ra)} = ${fmt(data.Eb)}`); changed=true; }
        if (data.Eb!=null && data.Ia!=null && data.Ra==null && data.V!=null) { if (data.Ia!==0) { data.Ra = (data.V - data.Eb) / data.Ia; pushStep(steps, `R_a = (V - E_b)/I_a = (${fmt(data.V)} - ${fmt(data.Eb)}) / ${fmt(data.Ia)} = ${fmt(data.Ra)}`); changed=true; } }

        // Electromechanical constants if P and Z known
        if (data.P!=null && data.Z!=null && data.A!=null) {
          const kE = (data.P * data.Z) / (60 * data.A);
          const kT = (data.P * data.Z) / (2 * Math.PI * data.A);
          // Eb = kE * phi * N
          if (data.Eb!=null && data.N!=null && data.phi==null && kE!==0) { data.phi = data.Eb / (kE * data.N); pushStep(steps, `phi = E_b / (k_E * N) = ${fmt(data.Eb)} / (${fmt(kE)} * ${fmt(data.N)}) = ${fmt(data.phi)}`); changed=true; }
          if (data.phi!=null && data.N!=null && data.Eb==null) { data.Eb = kE * data.phi * data.N; pushStep(steps, `E_b = k_E * phi * N = ${fmt(kE)} * ${fmt(data.phi)} * ${fmt(data.N)} = ${fmt(data.Eb)}`); changed=true; }
          if (data.T!=null && data.Ia!=null && data.phi==null && kT!==0) { data.phi = data.T / (kT * data.Ia); pushStep(steps, `phi = T / (k_T * I_a) = ${fmt(data.T)} / (${fmt(kT)} * ${fmt(data.Ia)}) = ${fmt(data.phi)}`); changed=true; }
          if (data.phi!=null && data.Ia!=null && data.T==null) { data.T = kT * data.phi * data.Ia; pushStep(steps, `T = k_T * phi * I_a = ${fmt(kT)} * ${fmt(data.phi)} * ${fmt(data.Ia)} = ${fmt(data.T)}`); changed=true; }
          if (data.Eb!=null && data.phi!=null && data.N==null && kE!==0) { data.N = data.Eb / (kE * data.phi); pushStep(steps, `N = E_b / (k_E * phi) = ${fmt(data.Eb)} / (${fmt(kE)} * ${fmt(data.phi)}) = ${fmt(data.N)}`); changed=true; }
        }

        // If Eb known but not phi or N and only one of them known, try others (already covered)
      }

      // final notes
      if (iter>=30) pushStep(steps, 'Reached iteration limit — results may be incomplete. Provide more known values for unique solution.');
      return {data, steps};
    }

    function solveSeries(input) {
      const steps = [];
      const data = Object.assign({}, input);
      pushStep(steps, 'Solving as DC SERIES motor...');
      // Series: Ia = IL = If
      if (data.IL!=null && data.Ia==null) { data.Ia = data.IL; pushStep(steps, `I_a = I_L = ${fmt(data.IL)}`); }
      if (data.Ia!=null && data.IL==null) { data.IL = data.Ia; pushStep(steps, `I_L = I_a = ${fmt(data.Ia)}`); }

      let iter=0, changed=true;
      // default A
      if (!data.A) data.A = data.P || 2;
      pushStep(steps, `Using A = ${data.A}`);

      while (changed && iter<30) {
        changed = false; iter++;

        // total resistance
        if (data.Ra!=null && data.Rf!=null) {
          data.Rtot = data.Ra + data.Rf;
        }

        // Voltage equation -> Eb
        if (data.V!=null && data.IL!=null && data.Rtot!=null && data.Eb==null) {
          data.Eb = data.V - data.IL * data.Rtot;
          pushStep(steps, `E_b = V - I*(R_a+R_se) = ${fmt(data.V)} - ${fmt(data.IL)}*${fmt(data.Rtot)} = ${fmt(data.Eb)}`);
          changed=true;
        }

        // If Eb given but Rtot unknown we can find Rtot
        if (data.Eb!=null && data.IL!=null && data.Rtot==null && data.IL!==0 && data.V!=null) {
          data.Rtot = (data.V - data.Eb) / data.IL;
          pushStep(steps, `R_tot = (V - E_b)/I = (${fmt(data.V)} - ${fmt(data.Eb)}) / ${fmt(data.IL)} = ${fmt(data.Rtot)}`);
          changed=true;
        }

        if (data.Rtot!=null) {
          if (data.Ra==null && data.Rf!=null) { data.Ra = data.Rtot - data.Rf; pushStep(steps, `R_a = R_tot - R_se = ${fmt(data.Rtot)} - ${fmt(data.Rf)} = ${fmt(data.Ra)}`); changed=true; }
          if (data.Rf==null && data.Ra!=null) { data.Rf = data.Rtot - data.Ra; pushStep(steps, `R_se = R_tot - R_a = ${fmt(data.Rtot)} - ${fmt(data.Ra)} = ${fmt(data.Rf)}`); changed=true; }
        }

        // Electromechanical constants if P and Z known
        if (data.P!=null && data.Z!=null && data.A!=null) {
          const kE = (data.P * data.Z) / (60 * data.A);
          const kT = (data.P * data.Z) / (2 * Math.PI * data.A);

          // If phi known and Ia known, torque (use direct torque formula)
          if (data.phi!=null && data.Ia!=null && data.T==null) {
            data.T = kT * data.phi * data.Ia;
            pushStep(steps, `T = k_T * phi * I_a = ${fmt(kT)} * ${fmt(data.phi)} * ${fmt(data.Ia)} = ${fmt(data.T)}`);
            changed=true;
          }

          // If T and Ia known, get phi
          if (data.T!=null && data.Ia!=null && data.phi==null && kT!==0) {
            data.phi = data.T / (kT * data.Ia);
            pushStep(steps, `phi = T / (k_T * I_a) = ${fmt(data.T)} / (${fmt(kT)} * ${fmt(data.Ia)}) = ${fmt(data.phi)}`);
            changed=true;
          }

          // If Eb and phi known -> speed
          if (data.Eb!=null && data.phi!=null && data.N==null && kE!==0) {
            data.N = data.Eb / (kE * data.phi);
            pushStep(steps, `N = E_b / (k_E * phi) = ${fmt(data.Eb)} / (${fmt(kE)} * ${fmt(data.phi)}) = ${fmt(data.N)} (rpm)`);
            changed=true;
          }

          // If Eb, N and Ia known but phi unknown and phi depends on I, we can compute k_phi
          if (data.Eb!=null && data.N!=null && data.Ia!=null && !data.k_phi && kE * data.N * data.Ia !== 0) {
            data.k_phi = data.Eb / (kE * data.Ia * data.N);
            pushStep(steps, `k_phi = Eb / (k_E * I_a * N) = ${fmt(data.Eb)} / (${fmt(kE)} * ${fmt(data.Ia)} * ${fmt(data.N)}) = ${fmt(data.k_phi)}`);
            changed=true;
          }

          // If T known & Ia known, k_phi from T = kT * k_phi * Ia^2
          if (data.T!=null && data.Ia!=null && !data.k_phi && kT !== 0) {
            data.k_phi = data.T / (kT * data.Ia * data.Ia);
            pushStep(steps, `k_phi = T / (k_T * I_a^2) = ${fmt(data.T)} / (${fmt(kT)} * ${fmt(data.Ia)}^2) = ${fmt(data.k_phi)}`);
            changed=true;
          }

          // With k_phi we can relate Eb and N: Eb = kE * k_phi * Ia * N
          if (data.k_phi!=null && data.Ia!=null && data.N!=null && data.Eb==null) {
            data.Eb = kE * data.k_phi * data.Ia * data.N;
            pushStep(steps, `E_b = k_E * k_phi * I_a * N = ${fmt(kE)} * ${fmt(data.k_phi)} * ${fmt(data.Ia)} * ${fmt(data.N)} = ${fmt(data.Eb)}`);
            changed=true;
          }

          // With k_phi we can compute torque too
          if (data.k_phi!=null && data.Ia!=null && data.T==null) {
            data.T = kT * data.k_phi * data.Ia * data.Ia;
            pushStep(steps, `T = k_T * k_phi * I_a^2 = ${fmt(kT)} * ${fmt(data.k_phi)} * ${fmt(data.Ia)}^2 = ${fmt(data.T)}`);
            changed=true;
          }

          // If Eb and Ia known and N available we can compute torque via developed power too (alternative method)
          if (data.Eb!=null && data.Ia!=null && data.N!=null && data.T==null) {
            const omega = 2 * Math.PI * data.N / 60.0;
            if (omega !== 0) {
              const Pdev = data.Eb * data.Ia;
              data.T = Pdev / omega;
              pushStep(steps, `Alternative torque via P_dev = E_b * I_a = ${fmt(data.Eb)} * ${fmt(data.Ia)} = ${fmt(Pdev)} W; T = P_dev / ω = ${fmt(Pdev)} / ${fmt(omega)} = ${fmt(data.T)} N·m`);
              changed=true;
            }
          }
        }

        // If current and flux relation sometimes phi unknown
        if (data.phi==null && data.k_phi!=null && data.Ia!=null) {
          data.phi = data.k_phi * data.Ia;
          pushStep(steps, `phi = k_phi * I_a = ${fmt(data.k_phi)} * ${fmt(data.Ia)} = ${fmt(data.phi)}`);
          changed=true;
        }

      }

      if (iter>=30) pushStep(steps, 'Reached iteration limit — results may be incomplete. Provide more known values for unique solution.');
      return {data, steps};
    }

    function solveHandler() {
      const input = parseInputs();
      // validation: at least one numeric input
      const numericGiven = Object.keys(input).some(k => ['V','IL','Ra','Rf','Eb','Ia','If','N','phi','T','P','Z','A'].includes(k) && input[k]!=null);
      if (!numericGiven) { alert('Please enter at least one known numeric value'); return; }

      let solved;
      if (input.motor === 'shunt') solved = solveShunt(input);
      else solved = solveSeries(input);

      // show results (pick known+calculated)
      setResults(solved.data);
      // show steps
      el('steps-pre').textContent = solved.steps.join('\n');
    }

    // Buttons
    el('solve').addEventListener('click', solveHandler);
    el('clear').addEventListener('click', ()=>{
      ['V','IL','Ra','Rf','Eb','Ia','If','N','phi','T','P','Z','A'].forEach(id=>el(id).value='');
      el('results-list').innerHTML=''; el('steps-pre').textContent='No solution yet. Click Solve to compute.';
    });

    // load example (updated to the user's series motor example)
    el('example').addEventListener('click', ()=>{
      // example: Series motor (user-provided problem)
      el('motor-type').value = 'series';
      el('V').value = 250;
      el('P').value = 4;
      el('Z').value = 1254;
      el('A').value = 2;
      el('phi').value = 0.022; // 22 mWb
      el('Ra').value = 0.2;
      el('Rf').value = 0.3; // series field resistance
      el('Ia').value = 30; // armature/line current
      el('wanted').value='auto';
    });

    // export page as html
    el('export').addEventListener('click', ()=>{
      const blob = new Blob([document.documentElement.outerHTML], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'dc-motor-solver.html'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // update label for Rf depending on motor
    el('motor-type').addEventListener('change', (e)=>{
      const m = e.target.value;
      el('rf-label').textContent = (m==='shunt') ? 'Field / Shunt Resistance R_sh (Ω)' : 'Series Field Resistance R_se (Ω)';
    });

  </script>
</body>
</html>
